

# ДОКУМЕНТ 1: Техническая спецификация для разработчика

## Стратегия скальпинга ETH/USDT с использованием Range Model (RM)

### Версия: MVP 1.0

### Дата: 13.11.2025


***

## 1. Архитектура системы

### 1.1 Компоненты

```
┌─────────────────┐
│  RM Prediction  │ ← Python (FastAPI/Flask)
│     Service     │   Предоставляет прогнозы диапазона
└────────┬────────┘
         │ REST API
         ▼
┌─────────────────┐
│    Strategy     │ ← Node.js/Python
│     Service     │   Основная торговая логика
└────────┬────────┘
         │
         ├──► Binance WebSocket (market data)
         └──► Binance REST API (orders)
```


### 1.2 Технологический стек

- **RM Service**: Python 3.10+, FastAPI, LightGBM/sklearn
- **Strategy Service**: Node.js 18+ или Python 3.10+
- **Database**: Redis (state management, rate limiting)
- **Exchange**: Binance Futures API
- **Logging**: Winston/Python logging

[^5][^4]

***

## 2. Binance API Integration

### 2.1 WebSocket для получения цены (рекомендуется)

**Endpoint:**

```
wss://fstream.binance.com/ws/ethusdt@aggTrade
```

**Преимущества:**

- Real-time обновления (каждую секунду или чаще)
- Не считается в rate limit запросов
- Максимум 5 входящих сообщений в секунду от клиента
- До 1024 стримов на одно соединение

[^6][^2][^1]

**Пример подключения (Node.js):**

```javascript
const WebSocket = require('ws');
const ws = new WebSocket('wss://fstream.binance.com/ws/ethusdt@aggTrade');

let currentPrice = null;

ws.on('message', (data) => {
  const trade = JSON.parse(data);
  currentPrice = parseFloat(trade.p); // Текущая цена
});

ws.on('error', (error) => {
  console.error('WebSocket error:', error);
  // Реконнект логика
});
```


### 2.2 REST API для торговых операций

**Base URL:**

```
https://fapi.binance.com
```

**Rate Limits:**

- 6000 weight/minute (общий лимит)
- 300 соединений каждые 5 минут на IP

[^7][^1]

**Основные endpoints:**

```javascript
// 1. Установка плеча
POST /fapi/v1/leverage
{
  "symbol": "ETHUSDT",
  "leverage": 3
}
// Weight: 1

// 2. Установка margin type (ISOLATED рекомендуется)
POST /fapi/v1/marginType
{
  "symbol": "ETHUSDT",
  "marginType": "ISOLATED"
}
// Weight: 1

// 3. Открытие позиции LONG
POST /fapi/v1/order
{
  "symbol": "ETHUSDT",
  "side": "BUY",
  "type": "LIMIT",
  "quantity": "0.5",
  "price": "3485",
  "timeInForce": "GTC"
}
// Weight: 1

// 4. Установка Stop-Loss
POST /fapi/v1/order
{
  "symbol": "ETHUSDT",
  "side": "SELL",
  "type": "STOP_MARKET",
  "stopPrice": "3482.5",
  "closePosition": "true"
}
// Weight: 1

// 5. Установка Take-Profit
POST /fapi/v1/order
{
  "symbol": "ETHUSDT",
  "side": "SELL",
  "type": "TAKE_PROFIT_MARKET",
  "stopPrice": "3500",
  "closePosition": "true"
}
// Weight: 1
```


***

## 3. Конфигурация (config.json)

```json
{
  "exchange": {
    "name": "binance_futures",
    "testnet": true,
    "api_key": "YOUR_API_KEY",
    "api_secret": "YOUR_API_SECRET"
  },
  
  "trading": {
    "symbol": "ETHUSDT",
    "timeframe": "5m",
    "base_price": 3500,
    "range_percent": 0.005,
    
    "entry_threshold_long": 0.33,
    "entry_threshold_short": 0.67,
    "min_probability": 0.75,
    
    "tp_strategy": "midpoint",
    "fixed_rr_ratio": 3,
    
    "capital": 5000,
    "leverage": 3,
    "position_size": 0.5,
    "margin_type": "ISOLATED"
  },
  
  "risk_management": {
    "max_daily_loss": 200,
    "max_consecutive_losses": 3,
    "max_daily_trades": 30,
    "max_open_positions": 1
  },
  
  "monitoring": {
    "price_check_interval_ms": 1000,
    "prediction_update_interval_ms": 300000,
    "in_position_check_interval_ms": 1000
  },
  
  "rm_service": {
    "url": "http://localhost:8000",
    "endpoint": "/predict",
    "timeout_ms": 5000
  }
}
```


***

## 4. Основной алгоритм (Strategy Service)

### 4.1 Главный цикл

```javascript
const config = require('./config.json');
const BinanceClient = require('./binance_client');
const RMService = require('./rm_service');
const StateManager = require('./state_manager');

class ScalpingStrategy {
  constructor() {
    this.binance = new BinanceClient(config.exchange);
    this.rmService = new RMService(config.rm_service);
    this.state = new StateManager();
    
    this.currentPrice = null;
    this.currentPrediction = null;
    this.hasOpenPosition = false;
  }
  
  async initialize() {
    // 1. Установка leverage и margin type
    await this.binance.setLeverage(config.trading.symbol, config.trading.leverage);
    await this.binance.setMarginType(config.trading.symbol, config.trading.margin_type);
    
    // 2. Подключение к WebSocket для получения цены
    this.binance.subscribeToPrice(config.trading.symbol, (price) => {
      this.currentPrice = price;
    });
    
    // 3. Получение начального прогноза
    await this.updatePrediction();
    
    console.log('Strategy initialized');
  }
  
  async updatePrediction() {
    try {
      this.currentPrediction = await this.rmService.getPrediction({
        symbol: config.trading.symbol,
        timeframe: config.trading.timeframe,
        range_percent: config.trading.range_percent
      });
      
      console.log('Prediction updated:', this.currentPrediction);
    } catch (error) {
      console.error('Failed to update prediction:', error);
    }
  }
  
  calculatePosition(price, prediction) {
    const rangeWidth = prediction.range_upper - prediction.range_lower;
    return (price - prediction.range_lower) / rangeWidth;
  }
  
  async checkEntryConditions() {
    // Если уже в позиции - не проверяем
    if (this.hasOpenPosition) return;
    
    // Проверка лимитов
    if (this.state.isDailyLimitReached()) {
      console.log('Daily limits reached, skipping');
      return;
    }
    
    // Проверка наличия данных
    if (!this.currentPrice || !this.currentPrediction) return;
    
    // Фильтр по вероятности
    if (this.currentPrediction.probability < config.trading.min_probability) {
      console.log('Probability too low:', this.currentPrediction.probability);
      return;
    }
    
    // Расчет позиции в диапазоне
    const position = this.calculatePosition(this.currentPrice, this.currentPrediction);
    
    console.log(`Price: ${this.currentPrice}, Position: ${(position * 100).toFixed(2)}%`);
    
    // Проверка условий для LONG
    if (position <= config.trading.entry_threshold_long) {
      await this.openLongPosition();
    }
    
    // Проверка условий для SHORT
    else if (position >= config.trading.entry_threshold_short) {
      await this.openShortPosition();
    }
  }
  
  async openLongPosition() {
    console.log('Opening LONG position');
    
    const stopLoss = this.currentPrediction.range_lower;
    const takeProfit = this.calculateTakeProfit('LONG');
    
    try {
      // 1. Открываем основную позицию
      const order = await this.binance.createOrder({
        symbol: config.trading.symbol,
        side: 'BUY',
        type: 'MARKET',
        quantity: config.trading.position_size
      });
      
      // 2. Устанавливаем Stop-Loss
      await this.binance.createOrder({
        symbol: config.trading.symbol,
        side: 'SELL',
        type: 'STOP_MARKET',
        stopPrice: stopLoss,
        closePosition: true
      });
      
      // 3. Устанавливаем Take-Profit
      await this.binance.createOrder({
        symbol: config.trading.symbol,
        side: 'SELL',
        type: 'TAKE_PROFIT_MARKET',
        stopPrice: takeProfit,
        closePosition: true
      });
      
      this.hasOpenPosition = true;
      this.state.recordTrade({
        type: 'LONG',
        entry: this.currentPrice,
        stopLoss,
        takeProfit
      });
      
      console.log('LONG position opened:', {
        entry: this.currentPrice,
        stopLoss,
        takeProfit
      });
      
    } catch (error) {
      console.error('Failed to open LONG position:', error);
    }
  }
  
  async openShortPosition() {
    console.log('Opening SHORT position');
    
    const stopLoss = this.currentPrediction.range_upper;
    const takeProfit = this.calculateTakeProfit('SHORT');
    
    try {
      // 1. Открываем основную позицию
      const order = await this.binance.createOrder({
        symbol: config.trading.symbol,
        side: 'SELL',
        type: 'MARKET',
        quantity: config.trading.position_size
      });
      
      // 2. Устанавливаем Stop-Loss
      await this.binance.createOrder({
        symbol: config.trading.symbol,
        side: 'BUY',
        type: 'STOP_MARKET',
        stopPrice: stopLoss,
        closePosition: true
      });
      
      // 3. Устанавливаем Take-Profit
      await this.binance.createOrder({
        symbol: config.trading.symbol,
        side: 'BUY',
        type: 'TAKE_PROFIT_MARKET',
        stopPrice: takeProfit,
        closePosition: true
      });
      
      this.hasOpenPosition = true;
      this.state.recordTrade({
        type: 'SHORT',
        entry: this.currentPrice,
        stopLoss,
        takeProfit
      });
      
      console.log('SHORT position opened:', {
        entry: this.currentPrice,
        stopLoss,
        takeProfit
      });
      
    } catch (error) {
      console.error('Failed to open SHORT position:', error);
    }
  }
  
  calculateTakeProfit(direction) {
    const { range_lower, range_upper } = this.currentPrediction;
    
    switch (config.trading.tp_strategy) {
      case 'midpoint':
        return (range_lower + range_upper) / 2;
        
      case 'opposite_boundary':
        return direction === 'LONG' ? range_upper : range_lower;
        
      case 'fixed_rr':
        if (direction === 'LONG') {
          const risk = this.currentPrice - range_lower;
          return this.currentPrice + (risk * config.trading.fixed_rr_ratio);
        } else {
          const risk = range_upper - this.currentPrice;
          return this.currentPrice - (risk * config.trading.fixed_rr_ratio);
        }
        
      default:
        return (range_lower + range_upper) / 2;
    }
  }
  
  async monitorPosition() {
    // Проверяем статус позиции через API
    const position = await this.binance.getPosition(config.trading.symbol);
    
    if (!position || position.positionAmt === 0) {
      // Позиция закрыта
      if (this.hasOpenPosition) {
        console.log('Position closed');
        this.hasOpenPosition = false;
        this.state.positionClosed();
      }
    }
  }
  
  async run() {
    await this.initialize();
    
    // Обновление прогноза каждые 5 минут
    setInterval(() => {
      this.updatePrediction();
    }, config.monitoring.prediction_update_interval_ms);
    
    // Основной цикл проверки условий входа (когда НЕ в позиции)
    setInterval(async () => {
      if (!this.hasOpenPosition) {
        await this.checkEntryConditions();
      }
    }, config.monitoring.price_check_interval_ms);
    
    // Мониторинг позиции (когда В позиции)
    setInterval(async () => {
      if (this.hasOpenPosition) {
        await this.monitorPosition();
      }
    }, config.monitoring.in_position_check_interval_ms);
    
    console.log('Strategy is running...');
  }
}

// Запуск
const strategy = new ScalpingStrategy();
strategy.run().catch(console.error);
```


### 4.2 RM Service Client

```javascript
// rm_service.js
const axios = require('axios');

class RMService {
  constructor(config) {
    this.baseUrl = config.url;
    this.endpoint = config.endpoint;
    this.timeout = config.timeout_ms;
  }
  
  async getPrediction({ symbol, timeframe, range_percent }) {
    try {
      const response = await axios.post(
        `${this.baseUrl}${this.endpoint}`,
        {
          symbol,
          timeframe,
          range_percent
        },
        { timeout: this.timeout }
      );
      
      return {
        range_lower: response.data.range_lower,
        range_upper: response.data.range_upper,
        probability: response.data.probability,
        timestamp: response.data.timestamp
      };
      
    } catch (error) {
      throw new Error(`RM Service error: ${error.message}`);
    }
  }
}

module.exports = RMService;
```


### 4.3 State Manager (Redis)

```javascript
// state_manager.js
const Redis = require('ioredis');

class StateManager {
  constructor() {
    this.redis = new Redis();
    this.dailyKey = `trading:${new Date().toISOString().split('T')[^0]}`;
  }
  
  async recordTrade(trade) {
    await this.redis.lpush(`${this.dailyKey}:trades`, JSON.stringify(trade));
    await this.redis.incr(`${this.dailyKey}:count`);
  }
  
  async getDailyStats() {
    const count = await this.redis.get(`${this.dailyKey}:count`) || 0;
    const trades = await this.redis.lrange(`${this.dailyKey}:trades`, 0, -1);
    
    return {
      count: parseInt(count),
      trades: trades.map(t => JSON.parse(t))
    };
  }
  
  async isDailyLimitReached() {
    const stats = await this.getDailyStats();
    const config = require('./config.json');
    
    // Проверка максимального количества сделок
    if (stats.count >= config.risk_management.max_daily_trades) {
      return true;
    }
    
    // Проверка максимального убытка
    // TODO: реализовать подсчет PnL
    
    return false;
  }
  
  positionClosed() {
    // Обновление статистики после закрытия позиции
    console.log('Position closed, updating stats');
  }
}

module.exports = StateManager;
```


***

## 5. Оптимизация API запросов

### 5.1 Стратегия запросов

**Когда НЕ в позиции:**

- WebSocket: получение цены в real-time (не считается в rate limit)
- REST API: только для открытия позиции (~3 запроса на вход)
- Prediction API: каждые 5 минут (1 запрос)

**Когда В позиции:**

- WebSocket: получение цены в real-time
- REST API: проверка статуса позиции каждую секунду (1 запрос/сек)
- Prediction API: не запрашиваем (экономим ресурсы)

[^1][^6][^2]

### 5.2 Rate Limit Management

```javascript
class RateLimiter {
  constructor() {
    this.requestCount = 0;
    this.windowStart = Date.now();
    this.windowMs = 60000; // 1 минута
    this.maxRequests = 5000; // Оставляем запас от 6000
  }
  
  async checkLimit() {
    const now = Date.now();
    
    if (now - this.windowStart > this.windowMs) {
      // Новое окно
      this.requestCount = 0;
      this.windowStart = now;
    }
    
    if (this.requestCount >= this.maxRequests) {
      const waitTime = this.windowMs - (now - this.windowStart);
      console.log(`Rate limit approaching, waiting ${waitTime}ms`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
    
    this.requestCount++;
  }
}
```


***

## 6. Тестирование

### 6.1 Binance Testnet

**Futures Testnet URL:**

```
https://testnet.binancefuture.com
```

**WebSocket Testnet:**

```
wss://stream.binancefuture.com/ws
```

**Получение API ключей:**

1. Регистрация на https://testnet.binancefuture.com
2. Создание API ключа
3. Пополнение тестового баланса (кнопка "Get Test Funds")

[^8][^5]

### 6.2 Unit тесты

```javascript
// tests/strategy.test.js
const ScalpingStrategy = require('../strategy');

describe('ScalpingStrategy', () => {
  test('calculates position correctly', () => {
    const strategy = new ScalpingStrategy();
    const position = strategy.calculatePosition(3485, {
      range_lower: 3482.5,
      range_upper: 3517.5
    });
    expect(position).toBeCloseTo(0.071, 3);
  });
  
  test('generates LONG signal when position < threshold', () => {
    // TODO: implement
  });
  
  test('calculates take profit correctly', () => {
    // TODO: implement
  });
});
```


***

## 7. Мониторинг и логирование

### 7.1 Структура логов

```javascript
{
  "timestamp": "2025-11-13T13:00:00.000Z",
  "level": "info",
  "event": "position_opened",
  "data": {
    "type": "LONG",
    "entry_price": 3485,
    "stop_loss": 3482.5,
    "take_profit": 3500,
    "quantity": 0.5,
    "leverage": 3,
    "position_in_range": "7.1%",
    "probability": 88
  }
}
```


### 7.2 Метрики для мониторинга

- Количество сделок в день
- Win rate
- Average profit/loss
- Текущий PnL
- API request count
- WebSocket connection status
- RM Service latency

***

## 8. Deployment

### 8.1 Docker

```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install --production

COPY . .

CMD ["node", "index.js"]
```


### 8.2 Environment Variables

```bash
BINANCE_API_KEY=your_api_key
BINANCE_API_SECRET=your_api_secret
BINANCE_TESTNET=true
RM_SERVICE_URL=http://rm-service:8000
REDIS_URL=redis://redis:6379
```


***

## 9. Roadmap

### MVP (текущая версия)

- ✓ Базовая логика входа/выхода
- ✓ Интеграция с Binance Futures API
- ✓ Конфигурация через файл
- ✓ Простой риск-менеджмент


### v1.1

- [ ] Множественные диапазоны (0.3%, 0.5%, 0.8%)
- [ ] Динамическое плечо (2x-5x)
- [ ] Улучшенный мониторинг и алерты


### v2.0

- [ ] Интеграция индикаторов (ATR, Bollinger Bands)
- [ ] Machine Learning для оптимизации параметров
- [ ] Multi-symbol trading
- [ ] Web dashboard

[^4][^3]

***

**Конец технической спецификации**

***

# ДОКУМЕНТ 2: Логика стратегии (без технических деталей)

## Стратегия скальпинга ETH/USDT на основе прогнозирования диапазона

### Версия: MVP 1.0


***

## 1. Основная идея

Модель прогнозирования (RM) предсказывает, в каком диапазоне будет находиться цена ETH в ближайшие 5-15 минут (в зависимости от настроек) с определенной вероятностью.

Стратегия использует эти прогнозы для входа в позиции на границах диапазона и выхода в середине или на противоположной границе.

***

## 2. Настраиваемые параметры (задаются руками перед запуском)

### Базовые параметры

- **Актив**: ETH/USDT
- **Таймфрейм**: 5 минут (можно экспериментировать с 1м, 2м или 10, 11)
- **Базовая цена**: 3500 USDT (текущая цена для расчета диапазона)
- **Диапазон**: ±0.5% (можно тестировать 0.3%, 0.8%)


### Пороги входа

- **Порог LONG**: 33% (входим в покупку, когда цена ≤ 33% диапазона)
- **Порог SHORT**: 67% (входим в продажу, когда цена ≥ 67% диапазона)
Пороги можно менять, от агрессивных 40\60 до сейвовых  - 15\85
- **Минимальная вероятность**: >75%-80% (ниже не входим, если прогноз менее надежен)


### Управление капиталом

- **Капитал**: 5000 USDT
- **Плечо**: 3x (по умолчанию)
- **Размер позиции**: 0.5 ETH на сделку


### Лимиты риска

- **Максимальный убыток в день**: 200 USDT
- **Максимум убытков подряд**: 3
- **Максимум сделок в день**: 30


***

## 3. Логика работы

### Шаг 1: Получение прогноза

Каждые 5 минут система запрашивает у модели РМ прогноз:

- Нижняя граница диапазона: 3482.5
- Верхняя граница диапазона: 3517.5
- Вероятность: 88%

[^3]

### Шаг 2: Непрерывный мониторинг цены

Система **постоянно** (каждую секунду) получает текущую цену ETH через подписку на обновления биржи.[^9][^2]

### Шаг 3: Расчет позиции в диапазоне

Для каждой новой цены рассчитывается, где она находится относительно диапазона:

```
position = (текущая_цена - нижняя_граница) / ширина_диапазона
```

**Пример:**

- Цена: 3485
- Диапазон: 3482.5 - 3517.5 (ширина 35)
- position = (3485 - 3482.5) / 35 = 0.071 = 7.1%

[^3]

### Шаг 4: Проверка условий входа

**Если НЕТ открытой позиции:**

**Условие для LONG (покупка):**

- position ≤ 33% (цена в нижней части диапазона)
- Вероятность ≥ 75%
- Не превышены дневные лимиты

→ **Открываем LONG** сразу, как только условия выполнены

**Условие для SHORT (продажа):**

- position ≥ 67% (цена в верхней части диапазона)
- Вероятность ≥ 75%
- Не превышены дневные лимиты

→ **Открываем SHORT** сразу, как только условия выполнены

**Нейтральная зона (WAIT):**

- 33% < position < 67%
- Не входим, ждем движения к границам

[^3]

### Шаг 5: Открытие позиции

**Для LONG:**

1. Покупаем 0.5 ETH с плечом 3x по текущей цене
2. Устанавливаем Stop-Loss = нижняя граница (3482.5)
3. Устанавливаем Take-Profit = середина диапазона (3500)

**Для SHORT:**

1. Продаем 0.5 ETH с плечом 3x по текущей цене
2. Устанавливаем Stop-Loss = верхняя граница (3517.5)
3. Устанавливаем Take-Profit = середина диапазона (3500)

[^10][^3]

### Шаг 6: Мониторинг открытой позиции

**Пока позиция открыта:**

- Проверяем каждую секунду, закрылась ли позиция (по SL или TP)
- НЕ ищем новые точки входа
- НЕ запрашиваем новые прогнозы (экономим ресурсы)

**Когда позиция закрылась:**

- Фиксируем результат (прибыль/убыток)
- Обновляем статистику
- Возвращаемся к Шагу 1 (ищем новые возможности)

[^3]

***

## 4. Примеры работы

### Пример 1: Успешный LONG

**08:00:00** - Получен прогноз:

- Диапазон: 3482.5 - 3517.5
- Вероятность: 88%

**08:01:15** - Цена упала до 3485:

- position = 7.1% (< 33%)
- Условия выполнены → **Открываем LONG**
- Entry: 3485
- SL: 3482.5
- TP: 3500

**08:08:30** - Цена достигла Take-Profit 3500:

- Позиция закрыта автоматически
- Прибыль: (3500 - 3485) × 0.5 ETH × 3x = **22.5 USDT** (+0.45% от капитала)
- Время в позиции: 7 минут 15 секунд

[^3]

### Пример 2: Успешный SHORT

**13:00:00** - Получен прогноз:

- Диапазон: 3482.5 - 3517.5
- Вероятность: 91%

**13:02:45** - Цена выросла до 3516:

- position = 95.7% (> 67%)
- Условия выполнены → **Открываем SHORT**
- Entry: 3516
- SL: 3517.5
- TP: 3500

**13:11:20** - Цена достигла Take-Profit 3500:

- Позиция закрыта автоматически
- Прибыль: (3516 - 3500) × 0.5 ETH × 3x = **24 USDT** (+0.48% от капитала)
- Время в позиции: 8 минут 35 секунд

[^3]

### Пример 3: Убыток по Stop-Loss

**15:00:00** - Получен прогноз:

- Диапазон: 3482.5 - 3517.5
- Вероятность: 85%

**15:03:00** - Цена упала до 3484:

- position = 4.3% (< 33%)
- Условия выполнены → **Открываем LONG**
- Entry: 3484
- SL: 3482.5
- TP: 3500

**15:04:30** - Цена пробила диапазон вниз и достигла 3482.5:

- Сработал Stop-Loss
- Убыток: (3482.5 - 3484) × 0.5 ETH × 3x = **-2.25 USDT** (-0.045% от капитала)
- Время в позиции: 1 минута 30 секунд

[^3]

### Пример 4: Пропуск сигнала (низкая вероятность)

**17:00:00** - Получен прогноз:

- Диапазон: 3470 - 3530
- Вероятность: 65% ⚠️

**17:05:00** - Цена упала до 3475:

- position = 8.3% (< 33%)
- НО вероятность 65% < 75%
- **Пропускаем сигнал, не входим**



***

## 5. Варианты Take-Profit стратегий

### Вариант 1: Середина диапазона (по умолчанию)

- TP = (нижняя_граница + верхняя_граница) / 2
- **Плюсы**: сбалансированный R/R, высокая вероятность срабатывания
- **Минусы**: средняя прибыль


### Вариант 2: Противоположная граница (агрессивный)

- TP для LONG = верхняя граница
- TP для SHORT = нижняя граница
- **Плюсы**: максимальная прибыль
- **Минусы**: низкая вероятность срабатывания, долгое время в позиции


### Вариант 3: Фиксированный R/R (например 1:3)

- TP = Entry + (Risk × 3)
- **Плюсы**: четкое управление риском
- **Минусы**: может выходить за пределы прогнозируемого диапазона

[^3]

***

## 6. Влияние порогов входа на результаты

| Порог LONG/SHORT | Частота сделок | Risk/Reward | Рекомендация |
| :-- | :-- | :-- | :-- |
| 40% / 60% | Высокая | 1:0.3 | Не рекомендуется |
| 33% / 67% | Средняя | 1:0.5 | Стандарт для MVP |
| 25% / 75% | Низкая | 1:1 | Консервативный |
| 15% / 85% | Очень низкая | 1:2.3 | Очень консервативный |

**Рекомендация для экспериментов:**
Начать с 33%/67%, затем протестировать 25%/75% и сравнить результаты.[^3]

***

## 7. Сценарии работы в течение дня

### Утренняя сессия (08:00 - 10:00)

```
08:00 - Прогноз получен (P=88%)
08:01 - LONG вход @ 3485
08:08 - TP сработал @ 3500, +22.5 USDT ✓

08:15 - Новый прогноз (P=92%)
08:20 - SHORT вход @ 3515
08:25 - TP сработал @ 3500, +22.5 USDT ✓

08:30 - Новый прогноз (P=79%)
08:35 - LONG вход @ 3486
08:42 - TP сработал @ 3500, +21 USDT ✓

09:00 - Новый прогноз (P=68%)
09:10 - Цена @ 3484 (< 33%), но P < 75%
09:10 - Пропускаем вход ⊘

09:30 - Новый прогноз (P=91%)
09:35 - SHORT вход @ 3516
09:37 - SL сработал @ 3517.5, -2.25 USDT ✗
```

**Итог сессии:**

- Сделок: 4 (3 прибыльных, 1 убыточная)
- Win rate: 75%
- PnL: +63.75 USDT (+1.28% от капитала)

[^3]

***

## 8. Ключевые принципы

1. **Не гадаем** - входим только при выполнении четких условий
2. **Защищаем капитал** - всегда используем Stop-Loss на границе диапазона
3. **Фиксируем прибыль** - не жадничаем, закрываем по Take-Profit
4. **Учитываем вероятность** - чем выше P, тем надежнее сигнал
5. **Соблюдаем лимиты** - не торгуем после превышения дневных ограничений
6. **Экономим ресурсы** - активно мониторим только когда в позиции

[^4][^3]

***

**Конец описания логики стратегии**
<span style="display:none">[^11][^12]</span>

<div align="center">⁂</div>

[^1]: https://developers.binance.com/docs/binance-spot-api-docs/websocket-api/rate-limits

[^2]: https://developers.binance.com/docs/mining/general-info

[^3]: Strategy_Scalping_RM_FINAL_v2.md

[^4]: pishu-i-budem-potikhonku-razbi-ARYNLx_AS6iatNOBqX2jEQ.md

[^5]: https://developers.binance.com/docs/margin_trading/best-practice

[^6]: https://www.binance.com/en/academy/articles/what-are-binance-websocket-limits

[^7]: https://developers.binance.com/docs/derivatives/usds-margined-futures/websocket-api-general-info

[^8]: https://www.youtube.com/watch?v=BqGhgD6pXfs

[^9]: https://developers.binance.com/docs/binance-spot-api-docs/sbe-market-data-streams

[^10]: https://stackoverflow.com/questions/66926320/binance-api-proper-way-to-open-a-futures-trade

[^11]: https://www.binance.com/es/academy/articles/how-to-use-binance-websocket-api

[^12]: https://www.reddit.com/r/binance/comments/7h9exv/api_request_rate_limits/

